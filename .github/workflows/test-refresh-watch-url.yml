name: Refresh Stream watch_url (BG-only)

on:
  # Run twice per day (01:00 and 13:00 UTC)
  schedule:
    - cron: "0 1,13 * * *"
  # Run manually (optionally for a single file)
  workflow_dispatch:
    inputs:
      file:
        description: "Optional: path to a single film file (e.g. content/films/2025-geo-test.md)"
        required: false
        default: ""

permissions:
  contents: write

jobs:
  refresh:
    runs-on: ubuntu-latest
    env:
      ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
      API_TOKEN:  ${{ secrets.CF_API_TOKEN }}
      CF_SUBDOMAIN: ${{ vars.CF_CUSTOMER_SUBDOMAIN }} # e.g. customer-ojfdlxwm7xyjwjmt.cloudflarestream.com

    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Build target file list
        id: files
        shell: bash
        run: |
          set -euo pipefail
          if [[ -n "${{ github.event.inputs.file }}" ]]; then
            test -f "${{ github.event.inputs.file }}" || { echo "File not found"; exit 1; }
            printf '[%s]\n' "\"${{ github.event.inputs.file }}\"" > files.json
          else
            # All film files with show_watch_button: true
            mapfile -t list < <(grep -rlE '^[[:space:]]*show_watch_button:[[:space:]]*true[[:space:]]*$' content/films | sort || true)
            printf '%s\n' "${list[@]}" | jq -Rsc 'split("\n")|map(select(length>0))' > files.json
          fi
          echo "files=$(cat files.json)" >> "$GITHUB_OUTPUT"
          echo "Targets:"; cat files.json

      - name: Sign and update watch_url
        id: update
        if: ${{ steps.files.outputs.files != '[]' }}
        shell: bash
        env:
          FILES_JSON: ${{ steps.files.outputs.files }}
        run: |
          set -euo pipefail
          changed=0
          readarray -t FILES < <(echo "$FILES_JSON" | jq -r '.[]')

          for f in "${FILES[@]}"; do
            [ -f "$f" ] || continue

            # must be explicitly enabled
            grep -Eq '^[[:space:]]*show_watch_button:[[:space:]]*true[[:space:]]*$' "$f" || { echo "skip: $f (button disabled)"; continue; }

            # get playback_id (fallback to legacy video_id)
            PID=$(awk -F': *' '
              BEGIN{pid=""}
              /^[[:space:]]*playback_id:/ {gsub(/"/,"",$2); if(pid=="") pid=$2}
              /^[[:space:]]*video_id:/    {gsub(/"/,"",$2); if(pid=="") pid=$2}
              END{print pid}
            ' "$f")

            if [[ -z "$PID" ]]; then
              echo "skip: $f (no playback_id/video_id)"; continue
            fi

            # Mint BG-only token. TTL set to 720 min (12h). Adjust if needed.
            JSON='{"ttl":720,"accessRules":[{"type":"ip.geoip.country","action":"allow","country":["BG"]}]}'
            TMP=$(mktemp)
            CODE=$(
              curl -sS -o "$TMP" -w "%{http_code}" \
                -X POST "https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/stream/${PID}/token" \
                -H "Authorization: Bearer ${API_TOKEN}" \
                -H "Content-Type: application/json" \
                --data "$JSON"
            )
            echo "HTTP $CODE for $PID"
            cat "$TMP"; echo
            [[ "$CODE" == "200" ]] || { echo "token mint failed for $PID"; continue; }

            TOKEN=$(jq -r '.result.token' < "$TMP")
            [[ -n "$TOKEN" && "$TOKEN" != "null" ]] || { echo "empty token for $PID"; continue; }

            WATCH_URL="https://${CF_SUBDOMAIN}/${PID}/iframe?preload=true&autoplay=true&token=${TOKEN}"

            # Replace existing watch_url (inside front matter) or insert after playback_id/video_id
            awk -v url="$WATCH_URL" '
              BEGIN{inFM=0; replaced=0}
              /^---[[:space:]]*$/ { fence++; inFM=(fence==1); print; next }
              {
                if (inFM && $0 ~ /^[[:space:]]*watch_url:/) {
                  print "watch_url: \"" url "\""; replaced=1; next
                }
                print
              }
              END{
                if (!replaced) {
                  # no-op: second pass will insert
                }
              }
            ' "$f" > "$f.tmp1"

            if ! grep -q '^[[:space:]]*watch_url:' "$f.tmp1"; then
              awk -v url="$WATCH_URL" '
                BEGIN{inFM=0; done=0}
                /^---[[:space:]]*$/ { fence++; inFM=(fence==1); print; next }
                {
                  print
                  if (inFM && !done && $0 ~ /^[[:space:]]*(playback_id|video_id):/) {
                    print "watch_url: \"" url "\""; done=1
                  }
                }
              ' "$f.tmp1" > "$f.tmp2"
              mv "$f.tmp2" "$f.tmp1"
            fi

            mv "$f.tmp1" "$f"
            echo "updated: $f"
            changed=$((changed+1))
          done

          echo "changed=$changed" >> "$GITHUB_OUTPUT"

      - name: Commit changes (if any)
        if: ${{ steps.update.outputs.changed != '0' }}
        run: |
          git config user.name  "plankton-bot"
          git config user.email "actions@users.noreply.github.com"
          git add content/films
          git commit -m "chore: refresh watch_url (BG-only, scheduled/manual)"
          git push
