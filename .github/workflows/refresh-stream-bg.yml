- name: Find newest film (by date only) + extract video_id
  id: pick
  run: |
    python - <<'PY'
    import re, os, glob, yaml, sys, datetime
    from dateutil import parser as dp

    # Accept BOM/ZWSP/NBSP around separators; accept EOF right after closing ---
    def clean(s):
        return s.replace('\ufeff','').replace('\u200b','').replace('\xa0','')

    def read_front_matter(path):
        with open(path, 'r', encoding='utf-8') as f:
            txt = f.read()
        lines = txt.splitlines()
        start = None
        for i,l in enumerate(lines):
            if clean(l).strip() == '---':
                start = i
                break
        if start is None:
            print(f"skip (no front matter): {path}")
            return None, txt
        end = None
        for i in range(start+1, len(lines)):
            if clean(lines[i]).strip() == '---':
                end = i
                break
        if end is None:
            print(f"skip (no closing ---): {path}")
            return None, txt
        block = '\n'.join(lines[start+1:end])
        try:
            fm = yaml.safe_load(block) or {}
        except Exception as e:
            print(f"skip (YAML error): {path}: {e}")
            return None, txt
        body = '\n'.join(lines[end+1:])
        if txt.endswith('\n') and not body.endswith('\n'):
            body += '\n'
        return fm, body

    # Decap date format is "YYYY-MM-DD HH:mm:ssZZ". Normalize before parsing.
    def normalize_date_str(s):
        s = clean(str(s)).strip()
        # Ensure space between date and time (Decap uses space, not 'T')
        s = re.sub(r'^(\d{4}-\d{2}-\d{2})[T\s]+(\d{2}:\d{2}:\d{2})', r'\1 \2', s)
        # Fix accidental "Z+03:00"/"Z-03:00" → "+03:00"/"-03:00"
        s = re.sub(r'Z([+-]\d{2}:\d{2})$', r'\1', s)
        # Pure 'Z' → '+00:00'
        if s.endswith('Z'):
            s = s[:-1] + '+00:00'
        return s

    def parse_date_only(fm, path):
        v = fm.get('date')
        if v is None:
            print(f"skip (no 'date'): {path}")
            return None
        raw  = str(v)
        norm = normalize_date_str(raw)
        try:
            # Try exact Decap format first for speed/clarity
            dt = datetime.datetime.strptime(norm, "%Y-%m-%d %H:%M:%S%z")
        except Exception:
            # Fallback to dateutil for any edge cases
            try:
                dt = dp.parse(norm)
            except Exception as e:
                print(f"skip (bad 'date'): {path}: raw='{raw}' norm='{norm}' err={e}")
                return None
        # normalize to UTC
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=datetime.timezone.utc)
        else:
            dt = dt.astimezone(datetime.timezone.utc)
        print(f"candidate: {path}  date_raw='{raw}'  date_norm='{norm}'  parsed='{dt.isoformat()}'")
        return dt

    files = sorted(glob.glob('content/films/*.md'))
    if not files:
        print("::error::No files in content/films"); sys.exit(1)

    candidates = []
    for p in files:
        fm, _ = read_front_matter(p)
        if not fm:
            continue
        vid = (fm.get('video_id') or fm.get('video') or '').strip()
        if not vid:
            print(f"skip (no video_id): {p}")
            continue
        dt = parse_date_only(fm, p)
        if not dt:
            continue
        candidates.append((dt, p, vid))

    if not candidates:
        print("::error::No film with valid 'date' and 'video_id' found"); sys.exit(1)

    print("— Candidates (UTC, by 'date'):")
    for dt, p, vid in candidates:
        print(f"  {dt.isoformat()}  {p}  (video_id={vid})")

    # Sort newest first; tie-break by filename for deterministic choice
    candidates.sort(key=lambda x: (x[0], x[1]), reverse=True)
    dt, latest_path, vid = candidates[0]
    print(f"Picked newest: {latest_path} @ {dt.isoformat()}  (video_id={vid})")

    out = os.environ["GITHUB_OUTPUT"]
    with open(out, "a", encoding="utf-8") as fh:
        fh.write(f"path={latest_path}\n")
        fh.write(f"video_id={vid}\n")
    PY
